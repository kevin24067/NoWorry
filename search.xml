<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[PKI中常用到证书密钥申请文件及其转换]]></title>
      <url>%2FNoWorry%2F2017%2F04%2F19%2FPKI%2F</url>
      <content type="text"><![CDATA[PKI标准规范梳理PKI标准可以分为第一代和第二代标准。 第一代PKI标准主要包括美国RSA公司的公钥加密标准（Public Key Cryptography Standards，PKCS）系列国际电信联盟的ITU-T X.509、IETF组织的公钥基础设施X.509（Public Key Infrastructure X.509，PKIX）标准系列无线应用协议（Wireless Application Protocol ,WAP）论坛的无线公钥基础设施（Wireless Public Key Infrastructure，WPKI）标准等。第一代PKI标准主要是基于抽象语法符号（Abstract Syntax Notation One，ASN.1）编码的，实现比较困难，这也在一定程度上影响了标准的推广。 PKCS(Public Key Cryptography Standards)系列标准PKCS是由美国RSA数据安全公司及其合作伙伴制定的一组公钥密码学标准，其中包括证书申请、证书更新、证书作废表发布、扩展证书内容以及数字签名、数字信封的格式等方面的一系列相关协议。到1999年底，PKCS已经公布了以下标准：PKCS#1：定义RSA公开密钥算法加密和签名机制，主要用于组织PKCS#7中所描述的数字签名和数字信封。https://tools.ietf.org/html/rfc2313.htmlPKCS#3：定义Diffie-Hellman密钥交换协议。PKCS#5：描述一种利用从口令派生出来的安全密钥加密字符串的方法。使用MD2或MD5从口令中派生密钥，并采用DES-CBC模式加密。主要用于加密从一个计算机传送到另一个计算机的私人密钥，不能用于加密消息。PKCS#6：描述了公钥证书的标准语法，主要描述X.509证书的扩展格式。PKCS#7：定义一种通用的消息语法，包括数字签名和加密等用于增强的加密机制，PKCS#7与PEM兼容，所以不需其他密码操作，就可以将加密的消息转换成PEM消息。https://tools.ietf.org/html/rfc2315PKCS#8：描述私有密钥信息格式，该信息包括公开密钥算法的私有密钥以及可选的属性集等。PKCS#9：定义一些用于PKCS#6证书扩展、PKCS#7数字签名和PKCS#8私钥加密信息的属性类型。PKCS#10：描述证书请求语法。PKCS#11：称为Cyptoki，定义了一套独立于技术的程序设计接口，用于智能卡和PCMCIA卡之类的加密设备。PKCS#12：描述个人信息交换语法标准。描述了将用户公钥、私钥、证书和其他相关信息打包的语法。https://tools.ietf.org/html/rfc7292PKCS#13：椭圆曲线密码体制标准。PKCS#14：伪随机数生成标准。PKCS#15：密码令牌信息格式标准。 X.509是由国际电信联盟（ITU-T）制定的数字证书标准。在X.500确保用户名称惟一性的基础上，X.509为X.500用户名称提供了通信实体的鉴别机制，并规定了实体鉴别过程中广泛适用的证书语法和数据接口。X.509证书由用户公共密钥和用户标识符组成。此外还包括版本号、证书序列号、CA标识符、签名算法标识、签发者名称、证书有效期等信息。这一标准的最新版本是X.509 v3，它定义了包含扩展信息的数字证书。该版数字证书提供了一个扩展信息字段，用来提供更多的灵活性及特殊应用环境下所需的信息传送。https://www.ietf.org/rfc/rfc5280.txt 第二代PKI标准在2001年，由微软、VeriSign和webMethods三家公司发布了XML密钥管理规范(XML Key Management Specification，XKMS)。 规范应用CER,PEM,DER,CRT,PFX,CRS等编码格式同样的X.509证书,可能有不同的编码格式,目前有以下两种编码格式. PEM - Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码.查看PEM格式证书的信息: 1openssl x509 -in certificate.pem -text -noout Apache和*NIX服务器偏向于使用这种编码格式. DER - Distinguished Encoding Rules,打开看是二进制格式,不可读.查看DER格式证书的信息: 1openssl x509 -in certificate.der -inform der -text -noout Java和Windows服务器偏向于使用这种编码格式. 相关的文件扩展名这是比较误导人的地方,虽然我们已经知道有PEM和DER这两种编码格式,但文件扩展名并不一定就叫”PEM”或者”DER”,常见的扩展名除了PEM和DER还有以下这些,它们除了编码格式可能不同之外,内容也有差别,但大多数都能相互转换编码格式. CRT - CRT应该是certificate的三个字母,其实还是证书的意思,常见于*NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码,相信你已经知道怎么辨别. CER - 还是certificate,还是证书,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码. KEY - 通常用来存放一个公钥或者私钥,并非X.509证书,编码同样的,可能是PEM,也可能是DER. 查看KEY的办法: 1openssl rsa -in mykey.key -text -noout 如果是DER格式的话,同理应该这样了: 1openssl rsa -in mykey.key -text -noout -inform der CSR - Certificate Signing Request,即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息),在生成这个申请的时候,同时也会生成一个私钥,私钥要自己保管好。查看的办法(如果是DER格式的话照旧加上-inform der,这里不写了)： 1openssl req -noout -text -in my.csr PFX/P12 - predecessor of PKCS#12,对nix服务器来说,一般CRT和KEY是分开存放在不同文件中的,但Windows的IIS则将它们存在一个PFX文件中,(因此这个文件包含了证书及私钥)这样会不会不安全？应该不会,PFX通常会有一个”*提取密码“,你想把里面的东西读取出来的话,它就要求你提供提取密码,PFX使用的时DER编码,如何把PFX转换为PEM编码？ 1openssl pkcs12 -in for-iis.pfx -out for-iis.pem -nodes 这个时候会提示你输入提取代码. for-iis.pem就是可读的文本. 生成pfx的命令类似这样: 1openssl pkcs12 -export -in certificate.crt -inkey privateKey.key -out certificate.pfx -certfile CACert.crt 其中CACert.crt是CA(权威证书颁发机构)的根证书,有的话也通过-certfile参数一起带进去.这么看来,PFX其实是个证书密钥库. JKS - 即Java Key Storage,这是Java的专利,跟OpenSSL关系不大,利用Java的一个叫”keytool”的工具,可以将PFX转为JKS,当然了,keytool也能直接生成JKS,不过在此就不多表了. 证书编码的转换 PEM转为DER 1openssl x509 -in cert.crt -outform der -out cert.der DER转为PEM 1openssl x509 -in cert.crt -inform der -outform pem -out cert.pem (提示:要转换KEY文件也类似,只不过把x509换成rsa,要转CSR的话,把x509换成req…) 获得证书 向权威证书颁发机构申请证书 把csr交给权威证书颁发机构,权威证书颁发机构对此进行签名,完成.保留好csr,当权威证书颁发机构颁发的证书过期的时候,你还可以用同样的csr来申请新的证书,key保持不变. 用这命令生成一个csr: 1openssl req -newkey rsa:2048 -new -nodes -keyout my.key -out my.csr 生成自签名的证书 在生成证书的过程中会要你填一堆的东西,其实真正要填的只有Common Name,通常填写你服务器的域名,如”yourcompany.com”,或者你服务器的IP地址,其它都可以留空的. 1openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.pem -out cert.pem 生产环境中还是不要使用自签的证书,否则浏览器会不认,或者如果你是企业应用的话能够强制让用户的浏览器接受你的自签证书也行.向权威机构要证书通常是要钱的,但现在也有免费的,仅仅需要一个简单的域名验证即可.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSL原理及openssl模拟]]></title>
      <url>%2FNoWorry%2F2017%2F04%2F19%2FHTTPS%2F</url>
      <content type="text"><![CDATA[参考文档 openssl 文档 https://www.openssl.org/docs/man1.0.2/apps/ SSL交互图SSL握手包含3大阶段 协定算法套件 互相验证身份 协定加密机制 SSL协议的客户端服务器连接握手过程大致如下： 客户端发送一个「ClientHello」消息，说明它支持的密码算法列表以及最高协议版本等必要的信息 服务器返回支持的SSL版本，加密算法列表，以及自己的证书等。如果客户端请求的资源需要认证，服务器请求客户端发送证书。 客户端首先验证服务器，如果认证失败，则断开连接，认证成功则执行下一步； 客户端发送pre-master secret(S)（用服务器的公钥加密）和自己的证书（如果服务器需要验证身份） 服务器验证客户端，用自己的私钥得到pre-master secret，然后经过一系列步骤生成master secret(K)。 客户端和服务器使用master secret生成对称密钥session key，之后传输的收据均使用session key(SS)加密解密。 客户端发送消息声明之后的数据用session key加密，并发送一条加密数据表明握手结束 服务器发送消息声明之后的数据用session key加密，并发送一条加密数据表明握手结束S-&gt;K-&gt;SS 一系列技术就不展开了！（自己也没有搞明白） 算法套件（the cipher suites） 123$ openssl ciphers -V -tls1|grep &quot;Enc=AESGCM(256)&quot; 0xC0,0x30 - ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH Au=RSA Enc=AESGCM(256) Mac=AEAD 0x00,0x9D - AES256-GCM-SHA384 TLSv1.2 Kx=RSA Au=RSA Enc=AESGCM(256) Mac=AEAD Kx：密钥协商交互算法Au : 身份认证算法Enc：加密算法（用于数据传输）Mac: 消息指纹（用于保证数据完整性） openssl调试12$ openssl versionOpenSSL 1.0.2h 3 May 2016 ##查看本地可以用算法套件查看本地可用TLS1.0 TLS1.1 TLS1.2的算法套件 grep 加密算法为AELSGCM(256)的所以算法 1$ openssl ciphers -V -tls1|grep &quot;Enc=AESGCM(256)&quot; openssl s_server 模拟https web server12345#创建密钥对openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes#启动HTTPS serveropenssl s_server -key key.pem -cert cert.pem -cipher &apos;ECDHE-RSA-AES256-GCM-SHA384&apos; -accept 443 -www openssl s_client 模拟 HTTPS client 指定算法套件1$ openssl s_client -cipher &apos;ECDHE-RSA-AES128-GCM-SHA256&apos; -connect 127.0.0.1:443 curl 调试HTTPS123456789101112131415161718192021222324252627282930#模拟握手异常$ curl -vvv --tlsv1.2 --ciphers &apos;AES256-GCM-SHA384&apos; https://localhost* Rebuilt URL to: https://localhost/* timeout on name lookup is not supported* Trying ::1... % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0* Trying 127.0.0.1...* Connected to localhost (127.0.0.1) port 443 (#0)* ALPN, offering h2* ALPN, offering http/1.1* Cipher selection: AES256-GCM-SHA384* successfully set certificate verify locations:* CAfile: C:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crt CApath: none* TLSv1.2 (OUT), TLS header, Certificate Status (22):&#125; [5 bytes data]* TLSv1.2 (OUT), TLS handshake, Client hello (1):&#125; [130 bytes data]* TLSv1.2 (IN), TLS header, Unknown (21):&#123; [5 bytes data]* TLSv1.2 (IN), TLS alert, Server hello (2):&#123; [2 bytes data]* error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake failure 0 0 0 0 0 0 0 0 --:--:-- --:--:-- --:--:-- 0* Closing connection 0curl: (35) error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake failure#正常连接curl -vvv --tlsv1.2 --ciphers &apos;ECDHE-RSA-AES128-GCM-SHA256&apos; https://localhost]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo GitHub blog搭建]]></title>
      <url>%2FNoWorry%2F2017%2F04%2F17%2F20170417%2F</url>
      <content type="text"><![CDATA[#ssh生产绑定1ssh-keygen -t rsa -b 4096 -C &quot;kevin24067@gmail.com&quot; 1eval $(ssh-agent -s) 1ssh-add ~/.ssh/id_rsa 1clip &lt; ~/.ssh/id_rsa.pub #安装插件1npm install hexo-deployer-git --save 1git config --global core.autocrlf false 1npm install hexo-generator-feed --save 1npm install -- save-dev hexo-util 1npm install hexo-generator-searchdb --save #创建博客123456hexo inithexo new post &quot;&quot;hexo ghexo shexo dhexo clean ##刪除文章 至 \source_posts 底下找到要刪除的文章，並刪除在 Hexo 的 Node Cmd 中執行 1hexo clean 刪掉根目錄下的 db.json 在 Hexo 的 Node Cmd 中執行 1hexo g 在 Hexo 的 Node Cmd 中執行1hexo d]]></content>
    </entry>

    
  
  
</search>
